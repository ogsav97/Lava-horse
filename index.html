<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Seahorse Lava Jump</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #051923;
      color: #e6f2ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(180deg, #06283D 0%, #0B3B59 50%, #0E4B6E 100%);
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }
    /* HUD */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      font-weight: 700;
      text-shadow: 0 2px 6px rgba(0,0,0,0.65);
    }
    #muteBtn {
      pointer-events: auto;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      color: #e6f2ff;
      border-radius: 8px;
      padding: 6px 10px;
      font-weight: 700;
    }
    /* Touch Controls */
    .controls {
      position: absolute;
      bottom: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      z-index: 2;
    }
    .btn {
      flex: 1;
      background: rgba(0,0,0,0.35);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 14px;
      padding: 14px 0;
      color: #e6f2ff;
      font-size: 18px;
      font-weight: 800;
      text-align: center;
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .btn:active {
      transform: translateY(1px) scale(0.99);
    }
    .btn.small {
      flex: 0.7;
    }
    /* Overlay messages */
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.25), rgba(0,0,0,0.55));
      color: #fff;
      text-align: center;
      padding: 24px;
      z-index: 3;
    }
    #overlay.hidden { display: none; }
    .title {
      font-size: clamp(22px, 5vw, 42px);
      letter-spacing: 1px;
    }
    .subtitle {
      opacity: 0.85;
      font-size: clamp(14px, 3vw, 18px);
    }
    .chip {
      display: inline-block;
      margin-top: 8px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      font-size: 12px;
    }
    /* Accessibility hint */
    #kbdHint {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0.7;
      font-size: 12px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>
    <div id="hud">
      <div id="score">Score: 0</div>
      <button id="muteBtn" aria-label="Toggle sound">ðŸ”Š</button>
    </div>
    <div id="overlay">
      <div class="title">Seahorse Lava Jump</div>
      <div class="subtitle">Bounce up the platforms. Tap <span class="chip">Shoot ðŸ”¥</span> or press <span class="chip">Space</span> to fire lava balls and clear enemies!</div>
      <div class="subtitle">Move with <span class="chip">â—€ â–¶</span> or the on-screen buttons.</div>
      <div class="chip">Tip: Landing on a platform auto-bounces you up</div>
      <button class="btn" id="startBtn">Start</button>
    </div>
    <div class="controls" id="touchControls">
      <button class="btn small" id="leftBtn">â—€</button>
      <button class="btn" id="shootBtn">Shoot ðŸ”¥</button>
      <button class="btn small" id="rightBtn">â–¶</button>
    </div>
    <div id="kbdHint">(Keyboard: Left/Right arrows or A/D to move, Space to shoot)</div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: false });
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR for perf
      let W = 0, H = 0;

      function resize() {
        W = canvas.clientWidth;
        H = canvas.clientHeight;
        canvas.width = Math.floor(W * dpr);
        canvas.height = Math.floor(H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener('resize', resize, { passive: true });
      resize();

      // Sounds (simple synthesized beeps)
      let muted = false;
      const audioCtx = (() => {
        try { return new (window.AudioContext || window.webkitAudioContext)(); }
        catch { return null; }
      })();
      function beep(freq=440, dur=0.07, type='sine', vol=0.03) {
        if (muted || !audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = vol;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      }

      // Game state
      const state = {
        running: false,
        gameOver: false,
        score: 0,
        best: parseInt(localStorage.getItem('seahorse_best')||'0',10),
        camY: 0,
        gravity: 0.38,
        bounceVel: -10.5,
        scrollThreshold: H * 0.5,
        platformGapMin: 60,
        platformGapMax: 110,
        platforms: [],
        enemies: [],
        bullets: [],
        bgBubbles: [],
      };

      // Player (seahorse) properties
      const player = {
        x: 0, y: 0, w: 26, h: 28,
        vx: 0, vy: 0,
        speed: 3.2,
        facing: 1,
        color: '#9EF01A', // bright seahorse green
        alive: true,
      };

      // Controls
      const keys = { left: false, right: false, shoot: false };
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const shootBtn = document.getElementById('shootBtn');
      const startBtn = document.getElementById('startBtn');
      const overlay = document.getElementById('overlay');
      const scoreEl = document.getElementById('score');
      const muteBtn = document.getElementById('muteBtn');

      function bindBtn(btn, prop) {
        const on = (e) => { e.preventDefault(); keys[prop] = true; };
        const off = (e) => { e.preventDefault(); keys[prop] = false; };
        btn.addEventListener('touchstart', on, { passive: false });
        btn.addEventListener('touchend', off, { passive: false });
        btn.addEventListener('touchcancel', off, { passive: false });
        btn.addEventListener('mousedown', on);
        // mouseup anywhere
        window.addEventListener('mouseup', off);
        window.addEventListener('blur', off);
      }
      bindBtn(leftBtn, 'left');
      bindBtn(rightBtn, 'right');
      bindBtn(shootBtn, 'shoot');

      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
        if (e.code === 'Space') keys.shoot = true;
      });
      window.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
        if (e.code === 'Space') keys.shoot = false;
      });

      muteBtn.addEventListener('click', () => {
        muted = !muted;
        muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
        if (!muted && audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      });

      startBtn.addEventListener('click', () => {
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        startGame();
      });

      function startGame() {
        overlay.classList.add('hidden');
        state.running = true;
        state.gameOver = false;
        state.score = 0;
        state.camY = 0;
        state.platforms.length = 0;
        state.enemies.length = 0;
        state.bullets.length = 0;
        state.bgBubbles.length = 0;
        player.alive = true;
        player.x = W * 0.5 - player.w * 0.5;
        player.y = H * 0.6;
        player.vx = 0;
        player.vy = -8; // start with a gentle upward motion
        generateInitialPlatforms();
        spawnBackgroundBubbles();
        lastTime = performance.now();
        lastShot = 0;
      }

      // Platform generation
      function generateInitialPlatforms() {
        let y = H - 20;
        // base platform
        state.platforms.push(makePlatform(W/2 - 40, y, 80, false));
        const steps = 30;
        for (let i = 0; i < steps; i++) {
          y -= rand(state.platformGapMin, state.platformGapMax);
          const platW = rand(60, 120);
          const x = rand(0, W - platW);
          const moving = Math.random() < Math.min(0.15 + state.score*0.0005, 0.35);
          state.platforms.push(makePlatform(x, y, platW, moving));
          // occasional enemy
          if (Math.random() < 0.08) {
            state.enemies.push(makeEnemy(rand(x, x+platW-20), y - 20));
          }
        }
      }

      function makePlatform(x, y, w, moving) {
        return {
          x, y, w, h: 12,
          moving,
          dir: Math.random() < 0.5 ? -1 : 1,
          speed: moving ? rand(0.6, 1.3) : 0,
        };
      }

      function makeEnemy(x, y) {
        return {
          x, y,
          vx: (Math.random() < 0.5 ? -1 : 1) * rand(0.5, 1.2),
          w: 22, h: 16,
          alive: true,
          t: 0,
        };
      }

      function spawnBackgroundBubbles() {
        state.bgBubbles.length = 0;
        for (let i = 0; i < 40; i++) {
          state.bgBubbles.push({
            x: Math.random() * W,
            y: Math.random() * H,
            r: rand(1, 3),
            vy: rand(-0.6, -0.2),
            alpha: rand(0.1, 0.45)
          });
        }
      }

      // Bullets
      function shoot() {
        const now = performance.now();
        if (now - lastShot < 180) return; // fire rate limit
        lastShot = now;
        const bx = player.x + player.w * 0.5 + (player.facing * 10);
        const by = player.y + player.h * 0.35;
        state.bullets.push({
          x: bx, y: by,
          vx: player.facing * 5.5,
          vy: -6.5,
          r: 5,
          life: 1600, // ms
          born: now
        });
        beep(740, 0.06, 'square', 0.04);
      }
      let lastShot = 0;

      // Utilities
      function rand(min, max) { return Math.random()*(max-min)+min; }
      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
      function rectsOverlap(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      // Game Loop
      let lastTime = 0;
      function loop(t) {
        if (!state.running) {
          requestAnimationFrame(loop);
          return;
        }
        const dt = Math.min(32, t - lastTime);
        lastTime = t;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      function update(dt) {
        // Controls
        if (keys.left && !keys.right) { player.vx = -player.speed; player.facing = -1; }
        else if (keys.right && !keys.left) { player.vx = player.speed; player.facing = 1; }
        else { player.vx *= 0.86; if (Math.abs(player.vx) < 0.05) player.vx = 0; }

        if (keys.shoot) shoot();

        // Physics
        player.vy += state.gravity;
        player.x += player.vx;
        player.y += player.vy;

        // Wrap horizontally
        if (player.x > W) player.x = -player.w;
        if (player.x + player.w < 0) player.x = W;

        // Platform movement and collision (bounce)
        for (const p of state.platforms) {
          if (p.moving) {
            p.x += p.speed * p.dir;
            if (p.x < 0) { p.x = 0; p.dir = 1; }
            else if (p.x + p.w > W) { p.x = W - p.w; p.dir = -1; }
          }
          // collision: coming down onto platform
          if (player.vy > 0 &&
              player.x + player.w*0.6 > p.x &&
              player.x + player.w*0.4 < p.x + p.w &&
              player.y + player.h > p.y &&
              player.y + player.h < p.y + p.h + 10) {
            player.y = p.y - player.h;
            player.vy = state.bounceVel;
            state.score += 1;
            beep(520, 0.05, 'triangle', 0.03);
          }
        }

        // Camera scrolling up when player climbs
        const targetCam = Math.min(state.camY, player.y - state.scrollThreshold);
        const dy = targetCam - state.camY;
        state.camY += dy * 0.07;

        // Spawn new platforms above
        const highest = state.platforms.reduce((min, p) => Math.min(min, p.y), Infinity);
        while (highest - state.camY > -H) {
          // Ensure enough platforms above
          const topY = state.platforms.reduce((min, p) => Math.min(min, p.y), Infinity);
          const gap = rand(state.platformGapMin, state.platformGapMax);
          const newY = topY - gap;
          const w = rand(60, 120);
          const x = rand(0, W - w);
          const moving = Math.random() < Math.min(0.2 + state.score*0.0007, 0.45);
          state.platforms.push(makePlatform(x, newY, w, moving));
          if (Math.random() < 0.12) state.enemies.push(makeEnemy(rand(x, x+w-20), newY - 20));
          break;
        }

        // Cull platforms below screen
        state.platforms = state.platforms.filter(p => p.y - state.camY < H + 60);

        // Enemies
        for (const e of state.enemies) {
          e.t += dt;
          e.x += e.vx;
          if (e.x < 0 || e.x + e.w > W) e.vx *= -1;
          // gentle bob
          e.y += Math.sin(e.t * 0.004) * 0.2;
          // Collision with player -> game over
          if (player.alive && rectsOverlap(player, e)) {
            player.alive = false;
            gameOver();
          }
        }
        // Cull enemies below
        state.enemies = state.enemies.filter(e => e.y - state.camY < H + 80 && e.alive);

        // Bullets
        const now = performance.now();
        for (const b of state.bullets) {
          b.x += b.vx;
          b.y += b.vy;
          b.vy += 0.12; // slight gravity arc
          // collide with enemies
          for (const e of state.enemies) {
            if (e.alive && b.x - b.r < e.x + e.w && b.x + b.r > e.x && b.y - b.r < e.y + e.h && b.y + b.r > e.y) {
              e.alive = false;
              b.life = 0;
              state.score += 5;
              beep(220, 0.06, 'sawtooth', 0.05);
            }
          }
        }
        state.bullets = state.bullets.filter(b => now - b.born < b.life && b.y - state.camY < H + 40 && b.x > -20 && b.x < W + 20);

        // Background bubbles
        for (const bb of state.bgBubbles) {
          bb.y += bb.vy;
          if (bb.y < -5) { bb.y = H + 5; bb.x = Math.random()*W; }
        }

        // Death: fall below screen
        if (player.y - state.camY > H + 60) {
          player.alive = false;
          gameOver();
        }

        // Update HUD
        scoreEl.textContent = `Score: ${state.score}  â€”  Best: ${state.best}`;
      }

      function gameOver() {
        if (state.gameOver) return;
        state.gameOver = true;
        state.running = false;
        state.best = Math.max(state.best, state.score);
        localStorage.setItem('seahorse_best', String(state.best));
        beep(160, 0.18, 'square', 0.06);
        showOverlay(true);
      }

      function showOverlay(isGameOver) {
        overlay.classList.remove('hidden');
        overlay.innerHTML = `
          <div class="title">${isGameOver ? 'Game Over' : 'Seahorse Lava Jump'}</div>
          <div class="subtitle">Score: <b>${state.score}</b>  â€¢  Best: <b>${state.best}</b></div>
          <div class="subtitle">Bounce up platforms to climb. Tap <span class="chip">Shoot ðŸ”¥</span> (or Space) to clear enemies.</div>
          <button class="btn" id="restartBtn">${isGameOver ? 'Play Again' : 'Start'}</button>
          <div class="chip">Move: â—€ â–¶ or A/D â€¢ Shoot: Space</div>
        `;
        document.getElementById('restartBtn').addEventListener('click', () => {
          startGame();
        });
      }

      // Drawing
      function draw() {
        // Background gradient (already via CSS), here draw subtle light beams
        ctx.clearRect(0, 0, W, H);
        drawBackground();
        // Translate for camera
        ctx.save();
        ctx.translate(0, -state.camY);

        // Platforms
        for (const p of state.platforms) drawPlatform(p);
        // Enemies
        for (const e of state.enemies) if (e.alive) drawEnemy(e);
        // Player
        if (player.alive) drawSeahorse(player);
        // Bullets
        for (const b of state.bullets) drawBullet(b);

        ctx.restore();
        // Foreground bubbles (screen space)
        drawForegroundBubbles();
      }

      function drawBackground() {
        // light shafts
        for (let i = 0; i < 3; i++) {
          const x = (i+1) * W/4;
          const grad = ctx.createLinearGradient(x, 0, x + W*0.12, H);
          grad.addColorStop(0, 'rgba(255,255,255,0.04)');
          grad.addColorStop(1, 'rgba(255,255,255,0.0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(x - W*0.08, 0);
          ctx.lineTo(x + W*0.12, 0);
          ctx.lineTo(x + W*0.02, H);
          ctx.lineTo(x - W*0.18, H);
          ctx.closePath();
          ctx.fill();
        }
      }

      function drawForegroundBubbles() {
        for (const bb of state.bgBubbles) {
          ctx.globalAlpha = bb.alpha;
          ctx.beginPath();
          ctx.arc(bb.x, bb.y, bb.r, 0, Math.PI*2);
          ctx.fillStyle = '#BDE0FE';
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function drawPlatform(p) {
        // platform base
        const r = 6;
        ctx.fillStyle = '#1E6091';
        roundRect(ctx, p.x, p.y, p.w, p.h, r, true, false);
        // top highlight
        ctx.fillStyle = '#A9D6E5';
        roundRect(ctx, p.x, p.y, p.w, 3, r, true, false);
      }

      function drawEnemy(e) {
        const { x, y, w, h } = e;
        // jellyfish-like enemy
        ctx.fillStyle = '#FF477E';
        roundRect(ctx, x, y, w, h, 6, true, false);
        // tentacles
        ctx.strokeStyle = 'rgba(255,100,150,0.8)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          const tx = x + 4 + i * (w-8)/3;
          ctx.beginPath();
          ctx.moveTo(tx, y+h);
          ctx.quadraticCurveTo(tx+4, y+h+6, tx-2, y+h+12);
          ctx.stroke();
        }
        // eyes
        ctx.fillStyle = '#2b1f24';
        ctx.fillRect(x+5, y+4, 4, 4);
        ctx.fillRect(x+w-9, y+4, 4, 4);
      }

      function drawSeahorse(s) {
        const { x, y, w, h } = s;
        ctx.save();
        // body
        ctx.fillStyle = s.color;
        roundRect(ctx, x, y+4, w*0.7, h-6, 10, true, false);
        // head
        ctx.beginPath();
        ctx.ellipse(x + (s.facing>0 ? w*0.55 : w*0.45), y+8, 10, 8, 0, 0, Math.PI*2);
        ctx.fill();
        // snout
        ctx.fillStyle = '#C7F9CC';
        const snX = x + (s.facing>0 ? w*0.70 : w*0.30);
        ctx.fillRect(snX - 2, y+8-2, 10, 4);
        // dorsal fin
        ctx.fillStyle = '#7AE582';
        ctx.beginPath();
        ctx.moveTo(x + w*0.2, y + h*0.25);
        ctx.lineTo(x - 6, y + h*0.35);
        ctx.lineTo(x + w*0.2, y + h*0.45);
        ctx.closePath();
        ctx.fill();
        // belly highlight
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#FFFFFF';
        roundRect(ctx, x+4, y+10, w*0.4, h*0.55, 8, true, false);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      function drawBullet(b) {
        const grd = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r*2.2);
        grd.addColorStop(0, '#FFF0');
        grd.addColorStop(0.3, '#FFD166');
        grd.addColorStop(0.7, '#EF476F');
        grd.addColorStop(1, '#8A1C3A');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
        // glow
        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r*2.2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      // Pause when hidden (mobile power save)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) { state.running = false; }
      });
      window.addEventListener('focus', () => {
        if (!state.gameOver && overlay.classList.contains('hidden')) { state.running = true; lastTime = performance.now(); }
      });
    })();
  </script>
</body>
</html>
